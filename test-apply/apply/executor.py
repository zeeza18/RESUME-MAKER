"""
Executes Playwright code generated by OpenAI with retry mechanism.
"""

import time
from typing import Dict, Any, Optional


class CodeExecutor:
    """Executes Playwright code with error handling and retries."""

    def __init__(self, logger, config):
        """
        Initialize executor.

        Args:
            logger: Logger instance
            config: Configuration object
        """
        self.logger = logger
        self.config = config
        self.max_retries = config.get('automation.max_code_retries', 3)
        self.action_delay = config.get('automation.action_delay', 1500) / 1000  # Convert to seconds

    def execute(
        self,
        page,
        playwright_code: str,
        description: str = "",
        retry_count: int = 0,
        iteration: int = 0
    ) -> Dict[str, Any]:
        """
        Execute Playwright code with retry mechanism.

        Args:
            page: Playwright page object
            playwright_code: Python code to execute
            description: Human-readable description
            retry_count: Current retry attempt
            iteration: Current iteration (for debug logging)

        Returns:
            {
                "success": bool,
                "error": str or None,
                "retry_count": int
            }
        """
        if not playwright_code:
            return {
                "success": False,
                "error": "No code provided",
                "retry_count": retry_count
            }

        self.logger.info(f"Executing: {description}")
        self.logger.debug(f"Code: {playwright_code}")

        # DEBUG: Save code being executed
        if iteration > 0:
            self.logger.save_iteration_debug(iteration, "code", playwright_code)

        try:
            # Create execution context with page object
            exec_globals = {
                'page': page,
                'time': time
            }

            # Execute the code
            exec(playwright_code, exec_globals)

            # Wait for action to complete
            time.sleep(self.action_delay)

            self.logger.info("Execution successful")

            # DEBUG: Save result
            if iteration > 0:
                self.logger.save_iteration_debug(
                    iteration, "result",
                    f"SUCCESS\nDescription: {description}\nCode: {playwright_code}"
                )

            return {
                "success": True,
                "error": None,
                "retry_count": retry_count
            }

        except Exception as e:
            error_msg = str(e)
            self.logger.warning(f"Execution failed: {error_msg}")

            # DEBUG: Save error
            if iteration > 0:
                self.logger.save_iteration_debug(
                    iteration, "result",
                    f"FAILED\nError: {error_msg}\nCode: {playwright_code}"
                )

            # Check if we should retry
            if retry_count < self.max_retries:
                self.logger.info(f"Retrying... (attempt {retry_count + 1}/{self.max_retries})")
                time.sleep(1)  # Brief pause before retry

                return {
                    "success": False,
                    "error": error_msg,
                    "retry_count": retry_count,
                    "should_retry": True
                }
            else:
                self.logger.error(f"Max retries ({self.max_retries}) reached")
                return {
                    "success": False,
                    "error": error_msg,
                    "retry_count": retry_count,
                    "should_retry": False
                }

    def execute_with_retry(
        self,
        page,
        playwright_code: str,
        description: str,
        brain,
        extraction_data: Dict[str, Any]
    ) -> bool:
        """
        Execute code with automatic retry and error healing.

        If code fails, re-extract page and ask OpenAI for new code.

        Args:
            page: Playwright page object
            playwright_code: Initial code to execute
            description: Description of action
            brain: UniversalBrain instance for regenerating code
            extraction_data: Current page extraction data

        Returns:
            True if successful after retries, False if all failed
        """
        attempt = 0

        while attempt < self.max_retries:
            result = self.execute(page, playwright_code, description, attempt)

            if result["success"]:
                return True

            # If failed and should retry, ask OpenAI for new code
            if result.get("should_retry", False):
                self.logger.warning(f"Code failed: {result['error']}")
                self.logger.info("Re-extracting page and asking OpenAI for new approach...")

                # TODO: Re-extract page here if needed
                # For now, just retry with same code but log the error
                attempt += 1
                time.sleep(1)
            else:
                # Max retries reached
                return False

        return False
